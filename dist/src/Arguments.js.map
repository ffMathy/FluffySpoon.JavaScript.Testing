{"version":3,"file":"Arguments.js","sourceRoot":"","sources":["../../src/Arguments.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA;IACI,kBACY,WAAmB,EACnB,gBAAqC;QADrC,gBAAW,GAAX,WAAW,CAAQ;QACnB,qBAAgB,GAAhB,gBAAgB,CAAqB;IAEjD,CAAC;IAED,0BAAO,GAAP,UAAQ,GAAM;QACV,OAAO,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;IACtC,CAAC;IAED,2BAAQ,GAAR;QACI,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IAED,0BAAO,GAAP;QACI,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IACL,eAAC;AAAD,CAAC,AAlBD,IAkBC;AAlBY,4BAAQ;AAoBrB;IAAkC,gCAAa;IAC3C;eACI,kBAAM,iBAAiB,EAAE,cAAM,OAAA,IAAI,EAAJ,CAAI,CAAC;IACxC,CAAC;IACL,mBAAC;AAAD,CAAC,AAJD,CAAkC,QAAQ,GAIzC;AAJY,oCAAY;AAMzB;IAAA;IAyCA,CAAC;IAxCU,OAAG,GAAV;QACI,OAAO,IAAI,YAAY,EAAE,CAAC;IAC9B,CAAC;IASM,OAAG,GAAV,UAAW,IAAa;QACpB,IAAM,WAAW,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,gBAAgB,GAAG,IAAI,GAAG,GAAG,CAAC;QACxE,OAAO,IAAI,QAAQ,CAAM,WAAW,EAAE,UAAA,CAAC;YACnC,IAAG,CAAC,IAAI;gBACJ,OAAO,IAAI,CAAC;YAEhB,IAAG,OAAO,CAAC,KAAK,WAAW;gBACvB,OAAO,IAAI,CAAC;YAEhB,IAAG,IAAI,KAAK,OAAO;gBACf,OAAO,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAEjC,OAAO,OAAO,CAAC,KAAK,IAAI,CAAC;QAC7B,CAAC,CAAC,CAAC;IACP,CAAC;IAEM,MAAE,GAAT,UAAa,SAAgC;QACzC,OAAO,IAAI,QAAQ,CAAI,0BAA0B,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,GAAG,GAAG,EAAE,SAAS,CAAQ,CAAC;IAC7G,CAAC;IAEc,eAAW,GAA1B,UAA2B,GAAQ;QAC/B,IAAG,OAAO,GAAG,CAAC,OAAO,KAAK,UAAU;YAChC,OAAO,GAAG,CAAC,OAAO,EAAE,CAAC;QAEzB,IAAG,OAAO,GAAG,CAAC,QAAQ,KAAK,UAAU;YACjC,OAAO,GAAG,CAAC,QAAQ,EAAE,CAAC;QAE1B,OAAO,GAAG,CAAC;IACf,CAAC;IACL,UAAC;AAAD,CAAC,AAzCD,IAyCC;AAzCY,kBAAG","sourcesContent":["export class Argument<T> {\r\n    constructor(\r\n        private description: string,\r\n        private matchingFunction: (arg: T) => boolean\r\n    ) {\r\n    }\r\n\r\n    matches(arg: T) {\r\n        return this.matchingFunction(arg);\r\n    }\r\n\r\n    toString() {\r\n        return this.description;\r\n    }\r\n\r\n    inspect() {\r\n        return this.description;\r\n    }\r\n}\r\n\r\nexport class AllArguments extends Argument<any> {\r\n    constructor() {\r\n        super('{all arguments}', () => true);\r\n    }\r\n}\r\n\r\nexport class Arg {\r\n    static all() {\r\n        return new AllArguments();\r\n    }\r\n\r\n    static any()\r\n    static any<T extends 'string'>(type: T): Argument<string> & string\r\n    static any<T extends 'number'>(type: T): Argument<number> & number\r\n    static any<T extends 'boolean'>(type: T): Argument<boolean> & boolean\r\n    static any<T extends 'array'>(type: T): Argument<any[]> & any[]\r\n    static any<T extends 'function'>(type: T): Argument<Function> & Function\r\n    static any<T extends 'string'|'number'|'boolean'|'symbol'|'undefined'|'object'|'function'|'array'>(type: T)\r\n    static any(type?: string): Argument<any> & any {\r\n        const description = !type ? '{any arg}' : '{arg matching ' + type + '}';\r\n        return new Argument<any>(description, x => {\r\n            if(!type)\r\n                return true;\r\n\r\n            if(typeof x === 'undefined')\r\n                return true;\r\n\r\n            if(type === 'array')\r\n                return x && Array.isArray(x);\r\n\r\n            return typeof x === type;\r\n        });\r\n    }\r\n\r\n    static is<T>(predicate: (input: T) => boolean): Argument<T> & T {\r\n        return new Argument<T>('{arg matching predicate ' + this.toStringify(predicate) + '}', predicate) as any;\r\n    }\r\n\r\n    private static toStringify(obj: any) {\r\n        if(typeof obj.inspect === 'function')\r\n            return obj.inspect();\r\n\r\n        if(typeof obj.toString === 'function')\r\n            return obj.toString();\r\n\r\n        return obj;\r\n    }\r\n}"]}